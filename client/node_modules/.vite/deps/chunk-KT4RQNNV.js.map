{
  "version": 3,
  "sources": ["../../@noble/hashes/_assert.js", "../../@noble/hashes/cryptoBrowser.js", "../../@noble/hashes/utils.js"],
  "sourcesContent": ["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\r\nfunction number(n) {\r\n    if (!Number.isSafeInteger(n) || n < 0)\r\n        throw new Error(`Wrong positive integer: ${n}`);\r\n}\r\nexports.number = number;\r\nfunction bool(b) {\r\n    if (typeof b !== 'boolean')\r\n        throw new Error(`Expected boolean, not ${b}`);\r\n}\r\nexports.bool = bool;\r\nfunction bytes(b, ...lengths) {\r\n    if (!(b instanceof Uint8Array))\r\n        throw new TypeError('Expected Uint8Array');\r\n    if (lengths.length > 0 && !lengths.includes(b.length))\r\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\r\n}\r\nexports.bytes = bytes;\r\nfunction hash(hash) {\r\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\r\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\r\n    number(hash.outputLen);\r\n    number(hash.blockLen);\r\n}\r\nexports.hash = hash;\r\nfunction exists(instance, checkFinished = true) {\r\n    if (instance.destroyed)\r\n        throw new Error('Hash instance has been destroyed');\r\n    if (checkFinished && instance.finished)\r\n        throw new Error('Hash#digest() has already been called');\r\n}\r\nexports.exists = exists;\r\nfunction output(out, instance) {\r\n    bytes(out);\r\n    const min = instance.outputLen;\r\n    if (out.length < min) {\r\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\r\n    }\r\n}\r\nexports.output = output;\r\nconst assert = {\r\n    number,\r\n    bool,\r\n    bytes,\r\n    hash,\r\n    exists,\r\n    output,\r\n};\r\nexports.default = assert;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.crypto = void 0;\r\nexports.crypto = {\r\n    node: undefined,\r\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\r\n};\r\n", "\"use strict\";\r\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\r\n// The import here is via the package name. This is to ensure\r\n// that exports mapping/resolution does fall into place.\r\nconst crypto_1 = require(\"@noble/hashes/crypto\");\r\n// Cast array to different type\r\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\r\nexports.u8 = u8;\r\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\r\nexports.u32 = u32;\r\n// Cast array to view\r\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\r\nexports.createView = createView;\r\n// The rotate right (circular right shift) operation for uint32\r\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\r\nexports.rotr = rotr;\r\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\r\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\r\n// So, just to be sure not to corrupt anything.\r\nif (!exports.isLE)\r\n    throw new Error('Non little-endian hardware is not supported');\r\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\r\n/**\r\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\r\n */\r\nfunction bytesToHex(uint8a) {\r\n    // pre-caching improves the speed 6x\r\n    if (!(uint8a instanceof Uint8Array))\r\n        throw new Error('Uint8Array expected');\r\n    let hex = '';\r\n    for (let i = 0; i < uint8a.length; i++) {\r\n        hex += hexes[uint8a[i]];\r\n    }\r\n    return hex;\r\n}\r\nexports.bytesToHex = bytesToHex;\r\n/**\r\n * @example hexToBytes('deadbeef')\r\n */\r\nfunction hexToBytes(hex) {\r\n    if (typeof hex !== 'string') {\r\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\r\n    }\r\n    if (hex.length % 2)\r\n        throw new Error('hexToBytes: received invalid unpadded hex');\r\n    const array = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < array.length; i++) {\r\n        const j = i * 2;\r\n        const hexByte = hex.slice(j, j + 2);\r\n        const byte = Number.parseInt(hexByte, 16);\r\n        if (Number.isNaN(byte) || byte < 0)\r\n            throw new Error('Invalid byte sequence');\r\n        array[i] = byte;\r\n    }\r\n    return array;\r\n}\r\nexports.hexToBytes = hexToBytes;\r\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\r\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\r\nconst nextTick = async () => { };\r\nexports.nextTick = nextTick;\r\n// Returns control to thread each 'tick' ms to avoid blocking\r\nasync function asyncLoop(iters, tick, cb) {\r\n    let ts = Date.now();\r\n    for (let i = 0; i < iters; i++) {\r\n        cb(i);\r\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\r\n        const diff = Date.now() - ts;\r\n        if (diff >= 0 && diff < tick)\r\n            continue;\r\n        await (0, exports.nextTick)();\r\n        ts += diff;\r\n    }\r\n}\r\nexports.asyncLoop = asyncLoop;\r\nfunction utf8ToBytes(str) {\r\n    if (typeof str !== 'string') {\r\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\r\n    }\r\n    return new TextEncoder().encode(str);\r\n}\r\nexports.utf8ToBytes = utf8ToBytes;\r\nfunction toBytes(data) {\r\n    if (typeof data === 'string')\r\n        data = utf8ToBytes(data);\r\n    if (!(data instanceof Uint8Array))\r\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\r\n    return data;\r\n}\r\nexports.toBytes = toBytes;\r\n/**\r\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\r\n * @example concatBytes(buf1, buf2)\r\n */\r\nfunction concatBytes(...arrays) {\r\n    if (!arrays.every((a) => a instanceof Uint8Array))\r\n        throw new Error('Uint8Array list expected');\r\n    if (arrays.length === 1)\r\n        return arrays[0];\r\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\r\n    const result = new Uint8Array(length);\r\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\r\n        const arr = arrays[i];\r\n        result.set(arr, pad);\r\n        pad += arr.length;\r\n    }\r\n    return result;\r\n}\r\nexports.concatBytes = concatBytes;\r\n// For runtime check if class implements interface\r\nclass Hash {\r\n    // Safe version that clones internal state\r\n    clone() {\r\n        return this._cloneInto();\r\n    }\r\n}\r\nexports.Hash = Hash;\r\n// Check if object doens't have custom constructor (like Uint8Array/Array)\r\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\r\nfunction checkOpts(defaults, opts) {\r\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\r\n        throw new TypeError('Options should be object or undefined');\r\n    const merged = Object.assign(defaults, opts);\r\n    return merged;\r\n}\r\nexports.checkOpts = checkOpts;\r\nfunction wrapConstructor(hashConstructor) {\r\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\r\n    const tmp = hashConstructor();\r\n    hashC.outputLen = tmp.outputLen;\r\n    hashC.blockLen = tmp.blockLen;\r\n    hashC.create = () => hashConstructor();\r\n    return hashC;\r\n}\r\nexports.wrapConstructor = wrapConstructor;\r\nfunction wrapConstructorWithOpts(hashCons) {\r\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\r\n    const tmp = hashCons({});\r\n    hashC.outputLen = tmp.outputLen;\r\n    hashC.blockLen = tmp.blockLen;\r\n    hashC.create = (opts) => hashCons(opts);\r\n    return hashC;\r\n}\r\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\r\n/**\r\n * Secure PRNG\r\n */\r\nfunction randomBytes(bytesLength = 32) {\r\n    if (crypto_1.crypto.web) {\r\n        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\r\n    }\r\n    else if (crypto_1.crypto.node) {\r\n        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\r\n    }\r\n    else {\r\n        throw new Error(\"The environment doesn't have randomBytes function\");\r\n    }\r\n}\r\nexports.randomBytes = randomBytes;\r\n"],
  "mappings": "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",
  "names": ["hash"]
}
